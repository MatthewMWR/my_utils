<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Hotspot Metrics</title>
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Crect width='64' height='64' rx='12' fill='%230b0e13'/%3E%3Cpath d='M16 46V18h8v20h8V18h8v28z' fill='%2373bf69'/%3E%3C/svg%3E">
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #0b0e13; color: #e0e0e0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; padding: 12px; }
  h1 { font-size: 16px; color: #888; text-align: center; margin-bottom: 8px; }
  .status-bar { display: flex; justify-content: center; gap: 16px; margin-bottom: 10px; font-size: 14px; }
  .status-bar .label { color: #888; }
  .status-bar .value { font-weight: 600; }
  .chart-container { width: 100%; height: 180px; background: #141619; border-radius: 6px; margin-bottom: 10px; position: relative; }
  canvas { width: 100% !important; height: 100% !important; }
  .gauges { display: grid; grid-template-columns: repeat(3, 1fr); gap: 6px; }
  .gauge { background: #141619; border-radius: 6px; padding: 10px; text-align: center; }
  .gauge .title { font-size: 10px; color: #888; text-transform: uppercase; margin-bottom: 4px; }
  .gauge .val { font-size: 28px; font-weight: 700; }
  .gauge .unit { font-size: 11px; color: #888; }
  .section-label { font-size: 12px; color: #666; margin: 8px 0 4px 4px; }
  .good { color: #73bf69; }
  .warn { color: #ff9830; }
  .bad { color: #f2495c; }
  .na { color: #555; }
  .quality-row { display: flex; gap: 6px; margin-bottom: 6px; }
  .quality-box { flex: 1; background: #141619; border-radius: 6px; padding: 12px; text-align: center; }
  .quality-box .val { font-size: 42px; font-weight: 700; }
  .quality-box .title { font-size: 11px; color: #888; }
  .stale-warning { display: none; text-align: center; color: #ff9830; font-size: 12px; margin-top: 4px; }
</style>
</head>
<body>
<h1>Hotspot Cellular Diagnostics</h1>
<div class="status-bar">
  <span><span class="label">Band </span><span class="value" id="band">—</span></span>
  <span><span class="label">Service </span><span class="value" id="svc">—</span></span>
  <span><span class="label">Source </span><span class="value" id="source">—</span></span>
  <span><span class="label">Last scrape attempt age </span><span class="value" id="scrape-age">—</span></span>
  <span><span class="label">Cell data age </span><span class="value" id="cell-data-age">—</span></span>
  <span><span class="label">Heartbeat age </span><span class="value" id="latency">—</span></span>
</div>

<div class="quality-row">
  <div class="quality-box">
    <div class="title">LTE Quality</div>
    <div class="val" id="lte-q">—</div>
  </div>
  <div class="quality-box">
    <div class="title">5G Quality</div>
    <div class="val" id="nr-q">—</div>
  </div>
</div>

<div class="chart-container"><canvas id="chart"></canvas></div>
<div class="chart-container"><canvas id="raw-chart"></canvas></div>

<div class="section-label">LTE</div>
<div class="gauges">
  <div class="gauge"><div class="title">RSRP</div><div class="val" id="lte-rsrp">—</div><div class="unit">dBm</div></div>
  <div class="gauge"><div class="title">RSRQ</div><div class="val" id="lte-rsrq">—</div><div class="unit">dB</div></div>
  <div class="gauge"><div class="title">SNR</div><div class="val" id="lte-snr">—</div><div class="unit">dB</div></div>
</div>
<div class="section-label">5G NR</div>
<div class="gauges">
  <div class="gauge"><div class="title">RSRP</div><div class="val" id="nr-rsrp">—</div><div class="unit">dBm</div></div>
  <div class="gauge"><div class="title">RSRQ</div><div class="val" id="nr-rsrq">—</div><div class="unit">dB</div></div>
  <div class="gauge"><div class="title">SNR</div><div class="val" id="nr-snr">—</div><div class="unit">dB</div></div>
</div>
<div class="stale-warning" id="stale">⚠ Data may be stale — last update <span id="stale-ago"></span></div>

<script>
var REFRESH = 3000;
var HISTORY = 120;
var HISTORY_POLL = 30000;
var sseConnected = false;
var lastHeartbeat = null;
var lastScrapeTimestamp = null;
var lastCellDataTimestamp = null;
var lastAppliedTimestamp = null;
var lastHeartbeatPoint = null;

function setHistoryWindow(seconds) {
  var parsed = parseInt(seconds, 10);
  if (isNaN(parsed) || parsed < 1) return false;
  if (parsed === HISTORY) return false;
  HISTORY = parsed;
  return true;
}

function qualityColor(v) {
  if (v == null) return 'na';
  if (v >= 60) return 'good';
  if (v >= 30) return 'warn';
  return 'bad';
}
function rsrpColor(v) {
  if (v == null) return 'na';
  if (v >= -90) return 'good';
  if (v >= -110) return 'warn';
  return 'bad';
}
function rsrqColor(v) {
  if (v == null) return 'na';
  if (v >= -10) return 'good';
  if (v >= -15) return 'warn';
  return 'bad';
}
function snrColor(v) {
  if (v == null) return 'na';
  if (v >= 10) return 'good';
  if (v >= 3) return 'warn';
  return 'bad';
}

function setVal(id, val, colorFn) {
  var el = document.getElementById(id);
  if (val == null || isNaN(val)) { el.textContent = 'n/a'; el.className = 'val na'; }
  else { el.textContent = Math.round(val); el.className = 'val ' + colorFn(val); }
}

function renderScrapeAge() {
  if (lastHeartbeat == null || isNaN(lastHeartbeat)) return;
  var age = Date.now() / 1000 - lastHeartbeat;
  if (age < 0) age = 0;
  var ageEl = document.getElementById('scrape-age');
  ageEl.textContent = age.toFixed(1) + 's';
  ageEl.className = 'value ' + (age < 3 ? 'good' : age < 12 ? 'warn' : 'bad');
  var staleEl = document.getElementById('stale');
  if (age > 60) { staleEl.style.display = 'block'; document.getElementById('stale-ago').textContent = age.toFixed(1) + 's'; }
  else staleEl.style.display = 'none';
}

function updateScrapeAge(heartbeatTs) {
  if (heartbeatTs == null || isNaN(heartbeatTs)) return;
  lastHeartbeat = heartbeatTs;
  renderScrapeAge();
}

function renderLatency() {
  var el = document.getElementById('latency');
  if (lastScrapeTimestamp == null || isNaN(lastScrapeTimestamp)) {
    el.textContent = '—';
    el.className = 'value na';
    return;
  }
  var age = Date.now() / 1000 - lastScrapeTimestamp;
  if (age < 0) age = 0;
  el.textContent = age.toFixed(1) + 's';
  el.className = 'value ' + (age < 3 ? 'good' : age < 12 ? 'warn' : 'bad');
}

function updateLatency(scrapeTs) {
  if (scrapeTs == null || isNaN(scrapeTs)) return;
  lastScrapeTimestamp = scrapeTs;
  renderLatency();
}

function isCellDataState(state) {
  return state === 'ok' || state === 'no_signal';
}

function renderCellDataAge() {
  var el = document.getElementById('cell-data-age');
  if (lastCellDataTimestamp == null || isNaN(lastCellDataTimestamp)) {
    el.textContent = '—';
    el.className = 'value na';
    return;
  }
  var age = Date.now() / 1000 - lastCellDataTimestamp;
  if (age < 0) age = 0;
  el.textContent = age.toFixed(1) + 's';
  el.className = 'value ' + (age < 12 ? 'good' : age < 60 ? 'warn' : 'bad');
}

function updateCellDataAge(sampleTs, sourceState) {
  if (sampleTs == null || isNaN(sampleTs)) return;
  if (!isCellDataState(sourceState)) return;
  if (lastCellDataTimestamp == null || sampleTs > lastCellDataTimestamp) {
    lastCellDataTimestamp = sampleTs;
  }
  renderCellDataAge();
}

function sourceCodeToState(code) {
  var c = code == null || isNaN(code) ? -1 : Math.round(code);
  if (c === 0) return { state: 'ok', label: 'OK', cls: 'good' };
  if (c === 1) return { state: 'no_signal', label: 'No signal', cls: 'warn' };
  if (c === 2) return { state: 'source_unavailable', label: 'Unavailable', cls: 'bad' };
  if (c === 3) return { state: 'parse_warning', label: 'Parse warn', cls: 'warn' };
  if (c === 4) return { state: 'scrape_error', label: 'Scrape error', cls: 'bad' };
  if (c === 5) return { state: 'startup_error', label: 'Startup error', cls: 'bad' };
  return { state: 'unknown', label: 'Unknown', cls: 'na' };
}

function setSourceStatus(state, message) {
  var el = document.getElementById('source');
  var mapped = sourceCodeToState(null);
  if (state === 'ok') mapped = sourceCodeToState(0);
  else if (state === 'no_signal') mapped = sourceCodeToState(1);
  else if (state === 'source_unavailable') mapped = sourceCodeToState(2);
  else if (state === 'parse_warning') mapped = sourceCodeToState(3);
  else if (state === 'scrape_error') mapped = sourceCodeToState(4);
  else if (state === 'startup_error') mapped = sourceCodeToState(5);
  el.textContent = mapped.label;
  el.className = 'value ' + mapped.cls;
  el.title = message || '';
}

function setSourceStatusFromCode(code) {
  var mapped = sourceCodeToState(code);
  setSourceStatus(mapped.state, '');
}

function fetchJson(path) {
  return fetch(path).then(function(r) {
    if (!r.ok) throw new Error('HTTP ' + r.status);
    return r.json();
  });
}

var canvas = document.getElementById('chart');
var ctx = canvas.getContext('2d');
var rawCanvas = document.getElementById('raw-chart');
var rawCtx = rawCanvas.getContext('2d');
var lteHistory = [], nrHistory = [], heartbeatHistory = [], scrapeHistory = [];
var lteRsrpHistory = [], lteRsrqHistory = [], lteSnrHistory = [];
var nrRsrpHistory = [], nrRsrqHistory = [], nrSnrHistory = [];

function drawChart() {
  var dpr = window.devicePixelRatio || 1;
  var rect = canvas.parentElement.getBoundingClientRect();
  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  ctx.scale(dpr, dpr);
  var W = rect.width, H = rect.height;
  var PAD = { top: 10, right: 10, bottom: 20, left: 35 };
  var cw = W - PAD.left - PAD.right;
  var ch = H - PAD.top - PAD.bottom;

  ctx.clearRect(0, 0, W, H);

  ctx.strokeStyle = '#222';
  ctx.lineWidth = 1;
  ctx.font = '10px sans-serif';
  ctx.fillStyle = '#555';
  for (var v = 0; v <= 100; v += 25) {
    var y = PAD.top + ch - (v / 100) * ch;
    ctx.beginPath(); ctx.moveTo(PAD.left, y); ctx.lineTo(W - PAD.right, y); ctx.stroke();
    ctx.fillText(v, 4, y + 3);
  }

  if (lteHistory.length === 0 && nrHistory.length === 0 && heartbeatHistory.length === 0 && scrapeHistory.length === 0) return;

  var now = Date.now();
  var tMin = now - HISTORY * 1000;
  var tMax = now;

  function drawLine(data, color) {
    if (data.length < 2) return;
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.beginPath();
    var started = false;
    for (var i = 0; i < data.length; i++) {
      var x = PAD.left + ((data[i].t - tMin) / (tMax - tMin)) * cw;
      var yv = Math.max(0, Math.min(100, data[i].v));
      var py = PAD.top + ch - (yv / 100) * ch;
      if (!started) { ctx.moveTo(x, py); started = true; }
      else ctx.lineTo(x, py);
    }
    ctx.stroke();
  }

  function drawHeartbeatDots(data) {
    if (data.length === 0) return;
    ctx.fillStyle = '#888';
    var y = PAD.top + 6;
    for (var i = 0; i < data.length; i++) {
      var x = PAD.left + ((data[i].t - tMin) / (tMax - tMin)) * cw;
      if (x < PAD.left || x > (W - PAD.right)) continue;
      ctx.beginPath();
      ctx.arc(x, y, 1.5, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function drawScrapeDots(data) {
    if (data.length === 0) return;
    ctx.fillStyle = '#f2cc0c';
    var y = PAD.top + 12;
    for (var i = 0; i < data.length; i++) {
      var x = PAD.left + ((data[i].t - tMin) / (tMax - tMin)) * cw;
      if (x < PAD.left || x > (W - PAD.right)) continue;
      ctx.beginPath();
      ctx.arc(x, y, 1.5, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  drawLine(lteHistory, '#5794f2');
  drawLine(nrHistory, '#e36ef2');
  drawHeartbeatDots(heartbeatHistory);
  drawScrapeDots(scrapeHistory);

  ctx.fillStyle = '#555';
  ctx.font = '10px sans-serif';
  for (var i = 0; i <= 6; i++) {
    var t = new Date(tMin + (i / 6) * (tMax - tMin));
    var lbl = ('0' + t.getHours()).slice(-2) + ':' + ('0' + t.getMinutes()).slice(-2);
    var lx = PAD.left + (i / 6) * cw;
    ctx.fillText(lbl, lx - 15, H - 4);
  }

  ctx.fillStyle = '#5794f2';
  ctx.fillRect(PAD.left + 8, PAD.top + 4, 12, 3);
  ctx.fillStyle = '#aaa';
  ctx.fillText('LTE', PAD.left + 24, PAD.top + 10);
  ctx.fillStyle = '#e36ef2';
  ctx.fillRect(PAD.left + 52, PAD.top + 4, 12, 3);
  ctx.fillStyle = '#aaa';
  ctx.fillText('5G', PAD.left + 68, PAD.top + 10);
  ctx.fillStyle = '#888';
  ctx.beginPath();
  ctx.arc(PAD.left + 97, PAD.top + 5.5, 1.5, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#aaa';
  ctx.fillText('HB', PAD.left + 104, PAD.top + 10);
  ctx.fillStyle = '#f2cc0c';
  ctx.beginPath();
  ctx.arc(PAD.left + 129, PAD.top + 5.5, 1.5, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#aaa';
  ctx.fillText('SCR', PAD.left + 136, PAD.top + 10);
}

function drawRawChart() {
  var dpr = window.devicePixelRatio || 1;
  var rect = rawCanvas.parentElement.getBoundingClientRect();
  rawCanvas.width = rect.width * dpr;
  rawCanvas.height = rect.height * dpr;
  rawCtx.scale(dpr, dpr);
  var W = rect.width, H = rect.height;
  var PAD = { top: 10, right: 10, bottom: 20, left: 40 };
  var cw = W - PAD.left - PAD.right;
  var ch = H - PAD.top - PAD.bottom;
  var YMIN = -120, YMAX = 30;

  rawCtx.clearRect(0, 0, W, H);

  rawCtx.strokeStyle = '#222';
  rawCtx.lineWidth = 1;
  rawCtx.font = '10px sans-serif';
  rawCtx.fillStyle = '#555';
  for (var v = YMIN; v <= YMAX; v += 30) {
    var y = PAD.top + ch - ((v - YMIN) / (YMAX - YMIN)) * ch;
    rawCtx.beginPath(); rawCtx.moveTo(PAD.left, y); rawCtx.lineTo(W - PAD.right, y); rawCtx.stroke();
    rawCtx.fillText(v, 6, y + 3);
  }

  var now = Date.now();
  var tMin = now - HISTORY * 1000;
  var tMax = now;

  function drawSeries(data, color) {
    if (data.length < 2) return;
    rawCtx.strokeStyle = color;
    rawCtx.lineWidth = 1.5;
    rawCtx.beginPath();
    var started = false;
    for (var i = 0; i < data.length; i++) {
      var x = PAD.left + ((data[i].t - tMin) / (tMax - tMin)) * cw;
      var yv = Math.max(YMIN, Math.min(YMAX, data[i].v));
      var py = PAD.top + ch - ((yv - YMIN) / (YMAX - YMIN)) * ch;
      if (!started) { rawCtx.moveTo(x, py); started = true; }
      else rawCtx.lineTo(x, py);
    }
    rawCtx.stroke();
  }

  drawSeries(lteRsrpHistory, '#5794f2');
  drawSeries(lteRsrqHistory, '#8ab8ff');
  drawSeries(lteSnrHistory, '#33a2ff');
  drawSeries(nrRsrpHistory, '#e36ef2');
  drawSeries(nrRsrqHistory, '#f4a1ff');
  drawSeries(nrSnrHistory, '#ff7adf');

  rawCtx.fillStyle = '#555';
  rawCtx.font = '10px sans-serif';
  for (var i = 0; i <= 6; i++) {
    var t = new Date(tMin + (i / 6) * (tMax - tMin));
    var lbl = ('0' + t.getHours()).slice(-2) + ':' + ('0' + t.getMinutes()).slice(-2);
    var lx = PAD.left + (i / 6) * cw;
    rawCtx.fillText(lbl, lx - 15, H - 4);
  }

  function legendDot(x, color, label) {
    rawCtx.fillStyle = color;
    rawCtx.fillRect(x, PAD.top + 3, 8, 2);
    rawCtx.fillStyle = '#aaa';
    rawCtx.fillText(label, x + 12, PAD.top + 10);
  }

  legendDot(PAD.left + 8, '#5794f2', 'L-RSRP');
  legendDot(PAD.left + 72, '#8ab8ff', 'L-RSRQ');
  legendDot(PAD.left + 136, '#33a2ff', 'L-SNR');
  legendDot(PAD.left + 190, '#e36ef2', 'N-RSRP');
  legendDot(PAD.left + 254, '#f4a1ff', 'N-RSRQ');
  legendDot(PAD.left + 318, '#ff7adf', 'N-SNR');
}

function applyLiveData(d) {
  if (!d) return;
  setHistoryWindow(d.dashboard_history_seconds);
  setVal('lte-q', d.lte_quality, qualityColor);
  setVal('nr-q', d.nr_quality, qualityColor);
  setVal('lte-rsrp', d.lte_rsrp, rsrpColor);
  setVal('lte-rsrq', d.lte_rsrq, rsrqColor);
  setVal('lte-snr', d.lte_snr, snrColor);
  setVal('nr-rsrp', d.nr_rsrp, rsrpColor);
  setVal('nr-rsrq', d.nr_rsrq, rsrqColor);
  setVal('nr-snr', d.nr_snr, snrColor);
  document.getElementById('band').textContent = d.band || '—';
  document.getElementById('svc').textContent = d.service_type || '—';
  setSourceStatus(d.source_state, d.source_message);
  if (d.scrape_unixtime) updateScrapeAge(d.scrape_unixtime);
  else if (d.timestamp) updateScrapeAge(d.timestamp);
  updateLatency(d.heartbeat_unixtime || d.timestamp);

  var heartbeatAdded = false;
  var heartbeatTs = d.heartbeat_unixtime || d.timestamp;
  if (heartbeatTs != null && !isNaN(heartbeatTs) && heartbeatTs !== lastHeartbeatPoint) {
    lastHeartbeatPoint = heartbeatTs;
    heartbeatHistory.push({ t: heartbeatTs * 1000 });
    heartbeatAdded = true;
  }

  var sampleAdded = false;
  var sampleTs = d.scrape_unixtime || d.timestamp;
  updateCellDataAge(sampleTs, d.source_state);
  if (sampleTs != null && !isNaN(sampleTs) && sampleTs !== lastAppliedTimestamp) {
    lastAppliedTimestamp = sampleTs;
    var now = sampleTs * 1000;
    scrapeHistory.push({ t: now });
    if (d.lte_rsrp != null && !isNaN(d.lte_rsrp)) lteRsrpHistory.push({ t: now, v: d.lte_rsrp });
    if (d.lte_rsrq != null && !isNaN(d.lte_rsrq)) lteRsrqHistory.push({ t: now, v: d.lte_rsrq });
    if (d.lte_snr != null && !isNaN(d.lte_snr)) lteSnrHistory.push({ t: now, v: d.lte_snr });
    if (d.nr_rsrp != null && !isNaN(d.nr_rsrp)) nrRsrpHistory.push({ t: now, v: d.nr_rsrp });
    if (d.nr_rsrq != null && !isNaN(d.nr_rsrq)) nrRsrqHistory.push({ t: now, v: d.nr_rsrq });
    if (d.nr_snr != null && !isNaN(d.nr_snr)) nrSnrHistory.push({ t: now, v: d.nr_snr });
    if (d.lte_quality != null && !isNaN(d.lte_quality)) lteHistory.push({ t: now, v: d.lte_quality });
    if (d.nr_quality != null && !isNaN(d.nr_quality)) nrHistory.push({ t: now, v: d.nr_quality });
    sampleAdded = true;
  }

  if (heartbeatAdded || sampleAdded) {
    var cutoff = Date.now() - HISTORY * 1000;
    lteHistory = lteHistory.filter(function(p) { return p.t >= cutoff; });
    nrHistory = nrHistory.filter(function(p) { return p.t >= cutoff; });
    heartbeatHistory = heartbeatHistory.filter(function(p) { return p.t >= cutoff; });
    scrapeHistory = scrapeHistory.filter(function(p) { return p.t >= cutoff; });
    lteRsrpHistory = lteRsrpHistory.filter(function(p) { return p.t >= cutoff; });
    lteRsrqHistory = lteRsrqHistory.filter(function(p) { return p.t >= cutoff; });
    lteSnrHistory = lteSnrHistory.filter(function(p) { return p.t >= cutoff; });
    nrRsrpHistory = nrRsrpHistory.filter(function(p) { return p.t >= cutoff; });
    nrRsrqHistory = nrRsrqHistory.filter(function(p) { return p.t >= cutoff; });
    nrSnrHistory = nrSnrHistory.filter(function(p) { return p.t >= cutoff; });
    drawChart();
    drawRawChart();
  }
}

function refreshSnapshot() {
  return fetchJson('/snapshot')
    .then(applyLiveData)
    .catch(function() {});
}

function connectSSE() {
  var es = new EventSource('/events');
  es.onopen = function() { sseConnected = true; };
  es.onmessage = function(e) {
    try { applyLiveData(JSON.parse(e.data)); } catch(err) {}
  };
  es.onerror = function() {
    sseConnected = false;
    es.close();
    setTimeout(connectSSE, 5000);
  };
}

function refreshHistory() {
  fetchJson('/history?seconds=' + HISTORY)
    .then(function(hist) {
    if (setHistoryWindow(hist.window_seconds)) {
      refreshHistory();
      return;
    }
    var points = Array.isArray(hist.points) ? hist.points : [];
    lteHistory = [];
    nrHistory = [];
    heartbeatHistory = [];
    scrapeHistory = [];
    lteRsrpHistory = [];
    lteRsrqHistory = [];
    lteSnrHistory = [];
    nrRsrpHistory = [];
    nrRsrqHistory = [];
    nrSnrHistory = [];
    lastCellDataTimestamp = null;
    lastAppliedTimestamp = null;
    lastHeartbeatPoint = null;
    for (var i = 0; i < points.length; i++) {
      var point = points[i];
      var hbTs = parseFloat(point.heartbeat_unixtime != null ? point.heartbeat_unixtime : point.timestamp);
      if (!isNaN(hbTs)) {
        heartbeatHistory.push({ t: hbTs * 1000 });
        lastHeartbeatPoint = hbTs;
      }
      var ts = parseFloat(point.scrape_unixtime != null ? point.scrape_unixtime : point.timestamp);
      if (isNaN(ts)) continue;
      scrapeHistory.push({ t: ts * 1000 });
      var lteRsrp = parseFloat(point.lte_rsrp);
      var lteRsrq = parseFloat(point.lte_rsrq);
      var lteSnr = parseFloat(point.lte_snr);
      var nrRsrp = parseFloat(point.nr_rsrp);
      var nrRsrq = parseFloat(point.nr_rsrq);
      var nrSnr = parseFloat(point.nr_snr);
      if (!isNaN(lteRsrp)) lteRsrpHistory.push({ t: ts * 1000, v: lteRsrp });
      if (!isNaN(lteRsrq)) lteRsrqHistory.push({ t: ts * 1000, v: lteRsrq });
      if (!isNaN(lteSnr)) lteSnrHistory.push({ t: ts * 1000, v: lteSnr });
      if (!isNaN(nrRsrp)) nrRsrpHistory.push({ t: ts * 1000, v: nrRsrp });
      if (!isNaN(nrRsrq)) nrRsrqHistory.push({ t: ts * 1000, v: nrRsrq });
      if (!isNaN(nrSnr)) nrSnrHistory.push({ t: ts * 1000, v: nrSnr });
      if (isCellDataState(point.source_state)) {
        lastCellDataTimestamp = ts;
      }
      if (point.lte_quality != null && !isNaN(point.lte_quality)) lteHistory.push({ t: ts * 1000, v: point.lte_quality });
      if (point.nr_quality != null && !isNaN(point.nr_quality)) nrHistory.push({ t: ts * 1000, v: point.nr_quality });
      lastAppliedTimestamp = ts;
    }
    renderCellDataAge();
    drawChart();
    drawRawChart();
  })
  .catch(function() {});
}

// Boot: load history from scraper, start SSE, fall back to snapshot polling
refreshSnapshot().finally(function() { refreshHistory(); });
connectSSE();
// Polling fallback when SSE is disconnected
setInterval(function() { if (!sseConnected) refreshSnapshot(); }, REFRESH);
setInterval(function() { if (!sseConnected) refreshHistory(); }, HISTORY_POLL);
setInterval(renderScrapeAge, 1000);
setInterval(renderCellDataAge, 1000);
setInterval(renderLatency, 1000);
window.addEventListener('resize', function() { drawChart(); drawRawChart(); });
</script>
</body>
</html>
